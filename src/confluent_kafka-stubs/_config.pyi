from collections.abc import Callable
from typing import Any, Literal, TypedDict

from confluent_kafka import ThrottleEvent
from confluent_kafka.cimpl import KafkaError

_BaseOptions = TypedDict(
    '_BaseOptions',
    {
        'builtin.features': str,
        'client.id': str,
        'metadata.broker.list': str,
        'message.max.bytes': int,
        'message.copy.max.bytes': int,
        'receive.message.max.bytes': int,
        'max.in.flight.requests.per.connection': int,
        'max.in.flight': int,
        'metadata.recovery.strategy': int,
        'topic.metadata.refresh.interval.ms': int,
        'metadata.max.age.ms': int,
        'topic.metadata.refresh.fast.interval.ms': int,
        'topic.metadata.refresh.fast.cnt': int,
        'topic.metadata.refresh.sparse': bool,
        'topic.metadata.propagation.max.ms': int,
        'topic.blacklist': str,
        'debug': str,
        'socket.timeout.ms': int,
        'socket.blocking.max.ms': int,
        'socket.send.buffer.bytes': int,
        'socket.receive.buffer.bytes': int,
        'socket.keepalive.enable': bool,
        'socket.nagle.disable': bool,
        'socket.max.fails': int,
        'broker.address.ttl': int,
        'broker.address.family': str,
        'socket.connection.setup.timeout.ms': int,
        'connections.max.idle.ms': int,
        'reconnect.backoff.jitter.ms': int,
        'reconnect.backoff.ms': int,
        'reconnect.backoff.max.ms': int,
        'statistics.interval.ms': int,
        'enabled_events': int,
        'error_cb': Callable[[KafkaError], None],
        'throttle_cb': Callable[[ThrottleEvent], None],
        'stats_cb': Callable[[str], None],
        'log_level': int,
        'log.queue': bool,
        'log.thread.name': str,
        'enable.random.seed': bool,
        'log.connection.close': bool,
        'background_event_cb': Callable[..., None],
        'socket_cb': Callable[..., None],
        'connect_cb': Callable[..., None],
        'closesocket_cb': Callable[..., None],
        'open_cb': Callable[..., None],
        'resolve_cb': Callable[..., None],
        'opaque': object,
        'default_topic_conf': object,
        'internal.termination.signal': int,
        'api.version.request': bool,
        'api.version.request.timeout.ms': int,
        'api.version.fallback.ms': int,
        'broker.version.fallback': str,
        'allow.auto.create.topics': bool,
        'security.protocol': Literal['plaintext', 'ssl', 'sasl_plaintext', 'sasl_ssl'],
        'ssl.cipher.suites': str,
        'ssl.curves.list': str,
        'ssl.sigalgs.list': str,
        'ssl.key.location': str,
        'ssl.key.password': str,
        'ssl.key.pem': str,
        'ssl_key': str,
        'ssl.certificate.location': str,
        'ssl.certificate.pem': str,
        'ssl_certificate': str,
        'ssl.ca.location': str,
        'ssl.ca.pem': str,
        'ssl_ca': str,
        'ssl.ca.certificate.stores': str,
        'ssl.crl.location': str,
        'ssl.keystore.location': str,
        'ssl.keystore.password': str,
        'ssl.providers': str,
        'ssl.engine.location': str,
        'ssl.engine.id': str,
        'ssl_engine_callback_data': Any,  # FIXME: Use proper type
        'enable.ssl.certificate.verification': bool,
        'ssl.endpoint.identification.algorithm': str,
        'ssl.certificate.verify_cb': Callable[..., None],
        'sasl.mechanisms': str,
        'sasl.mechanism': str,
        'sasl.kerberos.service.name': str,
        'sasl.kerberos.principal': str,
        'sasl.kerberos.kinit.cmd': str,
        'sasl.kerberos.keytab': str,
        'sasl.kerberos.min.time.before.relogin': int,
        'sasl.username': str,
        'sasl.password': str,
        'sasl.oauthbearer.config': Any,  # FIXME: Use proper type
        'enable.sasl.oauthbearer.unsecure.jwt': bool,
        'oauthbearer_token_refresh_cb': Callable[..., None],
        'sasl.oauthbearer.method': Literal['default', 'oidc'],
        'sasl.oauthbearer.client.id': str,
        'sasl.oauthbearer.client.secret': str,
        'sasl.oauthbearer.scope': str,
        'sasl.oauthbearer.extensions': str,
        'sasl.oauthbearer.token.endpoint.url': str,
        'plugin.library.paths': str,
        'interceptors': str,
        'client.rack': str,
        'retry.backoff.ms': int,
        'retry.backoff.max.ms': int,
        'client.dns.lookup': Literal['use_all_dns_ips', 'resolve_canonical_bootstrap_servers_only'],
        'enable.metrics.push': bool,
    },
    total=False,
)
_BaseRequiredOptions = TypedDict(
    '_BaseRequiredOptions',
    {
        'bootstrap.servers': str,
    },
    total=True,
)

class BaseConfig(_BaseOptions, _BaseRequiredOptions): ...

_ConsumerOptions = TypedDict(
    '_ConsumerOptions',
    {
        'group.instance.id': str,
        'partition.assignment.strategy': str,
        'session.timeout.ms': int,
        'heartbeat.interval.ms': int,
        'group.protocol.type': Literal['consumer'],
        'group.protocol': Literal['classic', 'consumer'],
        'group.remote.assignor': str,
        'coordinator.query.interval.ms': int,
        'max.poll.interval.ms': int,
        'enable.auto.commit': bool,
        'auto.commit.interval.ms': int,
        'enable.auto.offset.store': bool,
        'queued.min.messages': int,
        'queued.max.messages.kbytes': int,
        'fetch.wait.max.ms': int,
        'fetch.queue.backoff.ms': int,
        'fetch.message.max.bytes': int,
        'max.partition.fetch.bytes': int,
        'fetch.max.bytes': int,
        'fetch.min.bytes': int,
        'fetch.error.backoff.ms': int,
        'offset.store.method': Literal['none', 'file', 'broker'],
        'isolation.level': Literal['read_uncommitted', 'read_committed'],
        'consume_cb': Callable[..., None],
        'rebalance_cb': Callable[..., None],
        'offset_commit_cb': Callable[..., None],
        'enable.partition.eof': bool,
        'check.crcs': bool,
        'auto.commit.enable': bool,
        'auto.offset.reset': Literal['smallest', 'earliest', 'beginning', 'latest', 'largest', 'end', 'error'],
        'offset.store.path': str,
        'offset.store.sync.interval.ms': int,
        'consume.callback.max.messages': int,
    },
    total=False,
)
_ConsumerRequiredOptions = TypedDict(
    '_ConsumerRequiredOptions',
    {
        'group.id': str,
    },
    total=True,
)

class ConsumerConfig(BaseConfig, _ConsumerOptions, _ConsumerRequiredOptions): ...

_ProducerOptions = TypedDict(
    '_ProducerOptions',
    {
        'transactional.id': str,
        'transaction.timeout.ms': int,
        'enable.idempotence': bool,
        'enable.gapless.guarantee': bool,
        'queue.buffering.max.messages': int,
        'queue.buffering.max.kbytes': int,
        'queue.buffering.max.ms': int,
        'linger.ms': int,
        'message.send.max.retries': int,
        'retries': int,
        'retry.backoff.ms': int,
        'retry.backoff.max.ms': int,
        'queue.buffering.backpressure.threshold': int,
        'compression.codec': Literal['none', 'gzip', 'snappy', 'lz4', 'zstd'],
        'compression.type': Literal['none', 'gzip', 'snappy', 'lz4', 'zstd'],
        'batch.num.messages': int,
        'batch.size': int,
        'delivery.report.only.error': bool,
        'dr_cb': Callable[..., None],
        'dr_msg_cb': Callable[..., None],
        'sticky.partitioning.linger.ms': int,
        'request.required.acks': int,
        'acks': int,
        'request.timeout.ms': int,
        'message.timeout.ms': int,
        'delivery.timeout.ms': int,
        'queuing.strategy': Literal['fifo', 'lifo'],
        'produce.offset.report': bool,
        'partitioner': Literal[
            'random', 'consistent', 'consistent_random', 'murmur2', 'murmur2_random', 'fnv1a', 'fnv1a_random'
        ],
        'partitioner_cb': Callable[..., None],
        'msg_order_cmp': Callable[..., None],
    },
    total=False,
)

class ProducerConfig(BaseConfig, _ProducerOptions): ...
