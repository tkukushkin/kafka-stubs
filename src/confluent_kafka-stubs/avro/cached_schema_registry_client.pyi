from types import TracebackType
from typing import Any, Final, Literal, Never, Self, TypeAlias

try:
    from avro.schema import Schema
except ImportError:
    Schema: TypeAlias = Never  # type: ignore[no-redef]

VALID_LEVELS: Final[list[str]] = ...
VALID_METHODS: Final[list[str]] = ...
VALID_AUTH_PROVIDERS: Final[list[str]] = ...
ACCEPT_HDR: Final[str] = ...

class CachedSchemaRegistryClient:
    def __init__(
        self,
        url: str | dict[str, Any],
        max_schemas_per_subject: int = 1000,
        ca_location: str | None = None,
        cert_location: str | None = None,
        key_location: str | None = None,
    ) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(
        self,
        exception_type: type[BaseException] | None,
        exception: BaseException | None,
        traceback: TracebackType | None,
    ) -> None: ...
    def close(self) -> None: ...
    def register(self, subject: str, avro_schema: Schema) -> int: ...
    def check_registration(self, subject: str, avro_schema: Schema) -> int | None: ...
    def delete_subject(self, subject: str) -> int | None: ...
    def get_by_id(self, schema_id: int) -> Schema | None: ...
    def get_latest_schema(self, subject: str) -> tuple[None, None, None] | tuple[str, Schema, int]: ...
    def get_by_version(self, subject: str, version: int) -> tuple[None, None, None] | tuple[str, Schema, int]: ...
    def get_version(self, subject: str, avro_schema: Schema) -> int | None: ...
    def test_compatibility(
        self, subject: str, avro_schema: Schema, version: int | Literal['latest'] = 'latest'
    ) -> bool: ...
    def update_compatibility(
        self, level: Literal['NONE', 'FULL', 'FORWARD', 'BACKWARD'], subject: str | None = None
    ) -> bool: ...
    def get_compatibility(self, subject: str | None = None) -> Literal['NONE', 'FULL', 'FORWARD', 'BACKWARD']: ...
